/*****************************************************************************/
/** 
* \file       sky_pseudo_timer.c
* \author     yangkun
* \date       2016/11/21
* \version     V1.0
* \brief      伪定时器
* \note       Copyright (c) 2000-2020  金龙客车制造有限公司
* \remarks    输入修改日志
******************************************************************************/

/********************************************************************************
 *                               头文件引用                                     *
 ********************************************************************************/
#include "macro_def.h"

/********************************************************************************
 *                               局部常量定义                                   *
 ********************************************************************************/
#if CODE_PART("局部常量定义")

#endif

/********************************************************************************
 *                               局部宏定义                                     *
 ********************************************************************************/
#if CODE_PART("局部宏定义")
#define PSEUDO_TIME_SLICE    1    /*!< 伪定时器时间片(单位:s) */
#endif

/********************************************************************************
 *                               局部数据类型定义                               *
 ********************************************************************************/
#if CODE_PART("局部数据类型定义")
/**
 *\brief 伪定时器(dp不支持cos_timer定时器)
 */
typedef struct pseudo_timer_mgr_s
{
    BOOL init;
    BYTE pad[7];
    PTHREAD_MUTEX_T mutex;
    PTHREAD_T thread;    /*!< 伪定时器线程 */
}PSEUDO_TIMER_MGR;
#endif

/********************************************************************************
 *                               静态变量定义                                   *
 ********************************************************************************/
#if CODE_PART("静态变量定义")
static PSEUDO_TIMER_MGR g_pseudo_timer_mgr = {.init = FALSE};
#endif

/********************************************************************************
 *                               全局变量定义                                   *
 ********************************************************************************/
#if CODE_PART("全局变量定义")

#endif

/********************************************************************************
 *                               局部函数声明                                   *
 ********************************************************************************/
#if CODE_PART("局部函数声明")
extern void trace_flush();
#endif

/********************************************************************************
 *                               局部函数定义                                   *
 ********************************************************************************/
#if CODE_PART("局部函数定义")
/*****************************************************************************/
/** 
* \author      yangkun
* \date        2015/10/09
* \brief       伪定时器
* \param[out]  args    NULL
* \return      NULL
* \ingroup     sky_pseudo_timer
* \remarks     dp不支持cos_timer定时器,所以创建新线程通过sleep的方式实现
******************************************************************************/
void *pseudo_timer(VOID *args)
{
    PTHREAD_DETACH(PTHREAD_SELF);

    while(1)
    {
        SLEEP(PSEUDO_TIME_SLICE);
        /* 业务自行加锁处理 */
        trace_flush();
    }

    return NULL;
}
#endif

/********************************************************************************
 *                               全局函数定义                                   *
 ********************************************************************************/
#if CODE_PART("全局函数定义")
/*****************************************************************************/
/** 
* \author      yangkun
* \date        2016/11/21
* \brief       创建伪定时器
* \return      参见cos_return_code.h
* \ingroup     sky_pseudo_timer
* \remarks     每个进程仅支持一个
******************************************************************************/
WORD32 pseudo_timer_create()
{
    SWORD32 rc  = -1;
    WORD32  rtn = RTN_SUCCESS;

    rc = PTHREAD_MUTEX_LOCK(&g_pseudo_timer_mgr.mutex);
    //ASSERT(0 == rc);

    if(g_pseudo_timer_mgr.init)
    {
        goto EXIT;
    }

    rc = PTHREAD_CREATE(&(g_pseudo_timer_mgr.thread), NULL, pseudo_timer, NULL);
    if(0 != rc)
    {
        rtn = RTN_ERROR;
        //ASSERT(0);
        goto EXIT;
    }

    g_pseudo_timer_mgr.init = TRUE;

EXIT:
    rc = PTHREAD_MUTEX_UNLOCK(&g_pseudo_timer_mgr.mutex);
    //ASSERT(0 == rc);

    return rtn;
}
#endif

